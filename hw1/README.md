# Modules

ESM is the new standard for Javascript modules. The main selling point is that it allows code reuse in a standard manner no matter the platform that embeds the Javascript engine: Browser, Node.js, Mobile etc.

CommonJS format, although not standard, was extremly popular in both Node.js and Browser world until ESM appeared.
It's main disadvantage is that the Node.js module cannot be reused as it is in Browser, some transpiling and packaging is necessary - babel and webpack being the most used tools for this task.

Besides the short description above you will also notice the difference between the two regarding cyclic dependency handling by running the entry-points of the two chicken-egg modules.

Note that the cyclic dependency may happen often in real-life projects, although not desired. I chose to trigger an endless loop, but usually it's not the case - the cyclic dependency may be legit and benign in its nature.

Q1: What difference do you observe between the two and try to explain why this happens?

A1: The cjs example finishes running and outputs 'Egg was first' while the esm example enters an infinite loop and constantly outputs 'Asking the Chicken' --> 'Asking the Egg'. The cjs example works in the following way (I think...): the require from index.js sends us to Chicken.js and the require from there sends us to Egg.js. In Egg.js we see another require which would send us back to Chicken.js, but Chicken.js has already been required so the variable Chicken in Egg.js will be initialized with the existing object from the previous require. But that first require is not completed and there is no other properties that get added or initializations before the require that causes the cycle so the Chicken variable in Egg.js will be 'undefined'. Then execution continues normally, Egg is 'exported' and attributed to the Egg object in Chicken.js and then Chicken is 'exported' and 'imported' in index.js. Then calling Chicken.whoWasFirst() in index.js sends us to Chicken.js which has the 'this' object that points to the Chicken class and the closure Egg that points to the Egg class. Egg not being undefined enters the if statement, logs 'Asking the Egg' then calls Egg.whoWasFirst() which takes us to Egg.js where we have the local 'this' object refering to the Egg class and the closure Chicken which is undefined. Here the condition does not apply and we skip the if statement, logging 'typeof Chicken is undefined' and then 'Egg was first'. The esm example works in the following way (I think...): index.js imports Chicken and Chicken imports Egg. Because Chicken was already imported, the Chicken object in Egg.js will receive a reference to the Chicken class but without its definition. That happens because even though the class is defined below the import Egg command, the Chicken class is hoisted. And because in Egg.js we only use Chicken inside a function, not having the definition of the class if fine because we can wait for it. So in Egg.js Chicken gets the class but without its definition and exports Egg, then in Chicken.js we export Chicken and the Chicken from Egg.js will receive the class definition also. Thus both Chicken and Egg are defined and calling Chicken.whoWasFirst() triggers the loop.

There is another major difference between the two formats regarding how the symbols exported by a module are consumed by its clients. In order to observe it, run the entry-points of the two live-binding modules.

Q2: What difference do you observe between the two and try to explain why this happens?

A2: The cjs example outputs '0' and '0' before encountering an error (++counter; --> triggers 'Assigment to constant variable' error). The esm example ouputs '0' and '1' before encountering the same error. The difference in outputs happens because of a concept introduced in ES modules called live bindings. When a change is made in the exported module, the change will also be seen in the module that imports it because both the exporter and the importer point to the same memory location. When using cjs modules the require gives us a reference to the exports object in count.js and the changes are made to the module.exports (exports) object. Then any change on the exports object will be seen in every file that uses require. In our example, the increment function doesn't actually change the exports object.
